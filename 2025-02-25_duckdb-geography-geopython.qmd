---
title: "duckdb-geography: Global vector data in DuckDB"
subtitle: ""
author: "Dewey Dunnington, Wherobots Inc."
institute: ""
format:
  revealjs:
    embed-resources: true
    title-slide-attributes:
      data-background-image: bg/wb0.png
      data-background-color: "#2556BB"
---

```{r setup, include = FALSE}
library(s2)
reticulate::use_virtualenv(file.path(getwd(), ".venv"), required = TRUE)
```

## Me {background-image="bg/wb4.png"}

::: {style="text-align: center;"}

![](logo/arrow-hex.png){width="20%"} ![](logo/nanoarrow-hex.png){width="20%"} ![](logo/geoarrow_logo.png){width="20%"} ![](logo/sf.gif){width="20%"}

:::

::: {style="text-align: center;"}

![](logo/sedona_logo.png){width="70%"}

:::

::: {style="text-align: center;"}

![](logo/wherobots.png){width="50%"}

:::

## duckdb-geography {background-image="bg/wb3.png"}

In a nutshell:

```{python}
#| echo: true
import duckdb
con = duckdb.connect()

con.install_extension("geography", repository="community")

con.load_extension("geography")
con.table_function("s2_data_cities").limit(3)
```

```{python setup2, include = FALSE}
# import geoarrow.pyarrow as ga
con.load_extension("spatial")
con.sql("CALL register_geoarrow_extensions()")
```

## {background="#2556BB"}

<br/>

<br/>

::: {style="text-align: center;"}

### Data Types

<br/>

### Examples

<br/>

### The Future

:::

## Data types: Geography {background-image="bg/wb3.png"}

A Geography is a Geometry whose edges follow a the shortest distance on the Earth rather than the shortest distance in Cartesian/planar space

If you want to represent something like Fiji, Russia, or Antarctica without splitting it into pieces, you need Geography!

## Data types: Geography {background-image="bg/wb3.png"}

:::: {.columns}

::: {.column width="50%"}

Spherely array:

- Order is kept
- In memory data structures
- Requires explicit parallelization

:::

::: {.column width="50%"}

DuckDB Geography:

- Order is sometimes kept
- Serialized data structures (can be slower)
- Automatic parallelization

:::

::::

## Data types: Geography {background-image="bg/wb4.png"}

![](geography-is-coming.jpg){fig-align="center"}

...to Iceberg, Parquet, and Apache Sedona (and already exists in Python, R, Snowflake, PostGIS, BigQuery, SQL Server, and elsewhere)

## Data types: S2 Cell {background-image="bg/wb3.png"}

```{python}
#| echo: true
con.sql("""
SELECT s2_cellfromlonlat(7.64, 47.53).s2_cell_parent(level)
FROM (VALUES (5), (4), (3), (2), (1), (0)) levels(level)
""")
```

##


```{r}
#| fig-asp: 1
#| fig-width: 6
#| fig-align: center

base_plot <- function() {
  last_plot_env <- s2:::last_plot_env
  last_plot_env$centre <- s2_lnglat(7.64, 47.53)
  par(mai = rep(0, 4))
  plot(double(), double(), xlim = c(-1, 1), ylim = c(-1, 1), axes = FALSE, asp = 1, xlab = "", ylab = "")
  s2_plot(
    s2_data_countries(),
    centre = s2_lnglat(7.64, 47.53),
    plot_hemisphere = TRUE,
    lwd = 0.8,
    add = TRUE
  )
}

our_cells_plot <- function() {
  for (level in 5:0) {
    s2_lnglat(8, 46) |>
      as_s2_cell() |>
        s2_cell_parent(level) |>
        as_s2_cell_union() |>
        as_s2_geography() |>
        s2_plot(add = TRUE, simplify = FALSE, lwd = 1.5, border = "blue")
  }
}

base_plot()
our_cells_plot()
```

## Data types: S2 Cell {background-image="bg/wb3.png"}

S2 Cells are represented by `uint64_t` and have an important property: **containment can be calculated using a simple comparison**

::: {style="font-size: 90%;"}

```{python}
#| echo: true
con.sql("""
SELECT c, s2_cell_range_min(c), s2_cell_range_max(c)
FROM (VALUES ('2/0330'::S2_CELL)) cells(c)
""")
```

:::

## Data types: S2 Cell {background-image="bg/wb3.png"}

Cells are implicitly castable to Geography:

```{python}
#| echo: true
#| eval: false
con.sql("SELECT '2/0030'::S2_CELL::GEOGRAPHY AS geog")
```

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                                     geog                                     │
│                                  geography                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│ POLYGON ((56.88865803962798 44.96817331739243, 63.57747534364858 46.882504…  │
└──────────────────────────────────────────────────────────────────────────────┘
```

## Data types: S2 Cell Center {background-image="bg/wb3.png"}

```{python}
#| echo: true
(
    con
    .table_function("s2_data_cities")
    .select("geog")
    .limit(5)
)
```

## Data types: S2 Cell Center {background-image="bg/wb3.png"}

```{python}
#| echo: true
(
    con
    .table_function("s2_data_cities")
    .select("geog::S2_CELL_CENTER AS cell")
    .limit(5)
)
```

## Data types: S2 Cell Center {background-image="bg/wb3.png"}

```{python}
#| echo: true
(
    con
    .table_function("s2_data_cities")
    .select("geog::S2_CELL_CENTER::GEOGRAPHY AS cell")
    .limit(5)
)
```

## Data types: S2 Cell Union {background-image="bg/wb3.png"}

::: {style="font-size: 90%;"}

```{python}
#| echo: true
con.sql("SELECT s2_data_country('Switzerland').s2_covering()")
```

:::

## Data types: S2 Cell Union {background-image="bg/wb4.png"}

::: {style="font-size: 90%;"}

```{python}
#| echo: true
#| eval: false
con.sql("SELECT s2_data_country('Switzerland').s2_covering()")
```

:::

```{r}
#| fig-align: center

par(mai = rep(0, 4))
covering <- unclass(s2_covering_cell_ids(s2_data_countries("Switzerland")))[[1]] |> lapply(as_s2_cell_union)
covering <- do.call(c, as.list(covering))
s2_plot(covering, border = "blue")
s2_plot(s2_data_countries(), add = TRUE, lwd = 0.8)
s2_plot(covering, border = "blue", add = TRUE)
```

## Data types: S2 Cell Union {background-image="bg/wb3.png"}

Cells Unions are implicitly castable to Geography:

```{python}
#| echo: true
#| eval: false
con.sql("""
    SELECT s2_data_country('Switzerland').s2_covering()::GEOGRAPHY
""")
```

```
┌──────────────────────────────────────────────────────────────────────────────┐
│        CAST(s2_covering(s2_data_country('Switzerland')) AS GEOGRAPHY)        │
│                                  geography                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│ POLYGON ((8.851494069127982 48.37854425883403, 7.289681472358652 48.488487…  │
└──────────────────────────────────────────────────────────────────────────────┘
```

## {background="#2556BB"}

<br/>

<br/>

::: {style="text-align: center;"}

### Paralellizing a trivial workflow

<br/>

### Partitioning

<br/>

### Joining

:::

## Hands on: Parallelizing a workflow {background-image="bg/wb3.png"}

::: {style="font-size: 70%;"}

```{python}
#| echo: true
con.sql("""
SELECT s2_bounds_box_agg(geog) FROM s2_data_countries()
WHERE continent IN ('Oceania', 'Asia', 'Antarctica')
GROUP BY continent
""")
```

:::

## Hands on: Parallelizing a workflow {background-image="bg/wb4.png"}

Most useful for tasks that won't benefit from a spatial index and benefit from automagic global handling:

- `s2_bounds_box()` and `s2_bounds_box_agg()`
- `s2_area()`, `s2_distance()`, `s2_perimeter()`
- `s2_covering()`
- `::S2_CELL_CENTER`

For other tasks, consider DuckDB Spatial (if you don't need an index to assist with a join), PostGIS, or Apache Sedona (if you do).

## Hands on: Partitioning {background-image="bg/wb3.png"}

Take a porentially larger-than-memory dataset and split it into chunks based on location

```{python}
#| echo: true
con.load_extension("spatial")
con.sql("""
SELECT
  geometry.st_aswkb()
  .s2_arbitrarycellfromwkb().s2_cell_parent(3)
  .s2_cell_token() AS cell,
  *
FROM "microsoft-buildings_point_geo.parquet"
""").write_parquet(
  "microsoft-buildings-partitioned",
  partition_by=["cell"],
  overwrite=True
)
```

## Hands on: Partitioning

```{bash}
#| echo: true
ls -lh microsoft-buildings-partitioned/**/*.parquet
```

## Hands on: Partitioning {background-image="bg/wb3.png"}

```{python}
import geopandas

tab = con.read_parquet(
  "microsoft-buildings-partitioned/*/*.parquet",
  filename=True
).aggregate(
  "st_extent_agg(geometry) as geom",
  "filename"
).to_arrow_table()

(
    geopandas.GeoDataFrame.from_arrow(tab)
    .plot(edgecolor="black", facecolor="none")
)
```

## Hands on: Partitioning {background-image="bg/wb4.png"}

There are [more advanced ways to use DuckDB to do this](https://dewey.dunnington.ca/post/2024/partitioning-strategies-for-bigger-than-memory-spatial-data/#using-s2-cells-fixed-cell-level)

![](partitioning-ideal.png){fig-align="center"}

A KDBTree is often better (the next release of Apache Sedona will let you partition and write files like this)

## Hands on: Joining {background-image="bg/wb3.png"}

Let's count these by zipcode using geopandas?

```{python}
#| echo: true
#| eval: false
import geopandas
import pandas as pd

zipcodes_df = geopandas.read_parquet("us-zip-codes.parquet")
buildings_df = geopandas.read_parquet("microsoft-buildings_point_geo.parquet")
sindex = buildings_df.geometry.sindex
result = sindex.query(zipcodes_df.geometry, predicate="contains")
counts = pd.Series(result[0]).value_counts(sort=False)
```

(You might run out of memory)

## Hands on: Joining {background-image="bg/wb3.png"}

Let's count these by by zipcode using PostGIS?

```sql
SELECT zipcodes.zipcode, count(*) as numpoints
FROM zipcodes
JOIN buildings ON ST_Contains(zipcodes.geom, buildings.geom)
GROUP BY zipcodes.zipcode
```

(Getting the data into the database takes longer than the computation)

## Hands on: Joining {background-image="bg/wb3.png"}

Let's count these by zipcode using DuckDB spatial?

```sql
WITH
  buildings AS (SELECT * FROM "microsoft-buildings_point_geo.parquet"),
  zipcodes AS (SELECT * FROM "us-zip-codes.parquet")
SELECT zipcodes.zipcode, count(*) as numpoints
FROM zipcodes
JOIN buildings ON ST_Contains(zipcodes.geom, buildings.geometry)
GROUP BY zipcodes.zipcode
```

(DuckDB can't use an index for a join yet!)

## Hands on: Joining {background-image="bg/wb3.png"}

Let's count these by zipcode using WherobotsDB!

```python
config = SedonaContext.builder().getOrCreate()
sedona = SedonaContext.create(config)

sedona.read.format("shapefile").load("us-zip-codes.parquet")\
    .createOrReplaceTempView("zipcodes")
sedona.read.format("geoparquet").load("microsoft-buildings_point_geo.parquet")\
    .createOrReplaceTempView("buildings")

sedona.sql("""
    SELECT zipcodes.zipcode as zipcode, count(*) as numpoints
    FROM zipcodes
    JOIN buildings ON ST_Contains(zipcodes.geometry, buildings.geom)
    GROUP BY zipcode""")
```

## Hands on: Joining {background-image="bg/wb3.png"}

Let's count these by zipcode using DuckDB-geography!

```{python}
#| echo: true
#| output: false
#| eval: false
con.sql("""
  SELECT
    zipcode,
    geom.st_aswkb().s2_geogfromwkb() AS geog,
    geog.s2_covering() AS covering
  FROM "us-zip-codes.parquet"
""").to_view("zipcodes_original")
```

...by using S2 cells as something that DuckDB knows how to optimize the join for.

## Hands on: Joining {background-image="bg/wb3.png"}

```{python}
#| echo: true
#| eval: false
con.sql("""
  SELECT
    zipcode,
    geom.st_aswkb().s2_geogfromwkb().s2_prepare() AS geog,
    geog.s2_covering() AS covering
  FROM "us-zip-codes.parquet"
""").to_view("zipcodes_original")
```

```
┌─────────┬──────────────────────┬────────────────────────────────────────────────────────┐
│ zipcode │         geog         │                        covering                        │
│ varchar │      geography       │                     s2_cell_union                      │
├─────────┼──────────────────────┼────────────────────────────────────────────────────────┤
│ 15301   │ <S2ShapeIndex 9666…  │ [4/1001220212, 4/1001220221, 4/100122022211, 4/10012…  │
└─────────┴──────────────────────┴────────────────────────────────────────────────────────┘
```

## Hands on: Joining {background-image="bg/wb3.png"}

```{python}
#| echo: true
#| output: false
#| eval: false
con.sql("""
  SELECT
    unnest(covering) as cell,
    zipcode,
    geog,
    cell.s2_cell_range_min() AS cell_min,
    cell.s2_cell_range_max() AS cell_max
  FROM zipcodes_original""").to_table("zipcodes")
```

```
┌──────────────┬─────────┬──────────────────────┬──────────────────────┬────────────────────────────┐
│     cell     │ zipcode │         geog         │       cell_min       │          cell_max          │
│   s2_cell    │ varchar │      geography       │       s2_cell        │          s2_cell           │
├──────────────┼─────────┼──────────────────────┼──────────────────────┼────────────────────────────┤
│ 4/1001220212 │ 15301   │ <S2ShapeIndex 9666…  │  4/1001220212000000… │  4/1001220212333333333333… │
└──────────────┴─────────┴──────────────────────┴──────────────────────┴────────────────────────────┘
```

## Hands on: Joining {background-image="bg/wb3.png"}

```{python}
#| echo: true
#| output: false
#| eval: false
con.sql("""
    SELECT geometry.st_aswkb().s2_cellfromwkb() as cell
    FROM "microsoft-buildings_point_geo.parquet"
""").to_table("buildings")
```

```
┌──────────────────────────────────┐
│               cell               │
│          s2_cell_center          │
├──────────────────────────────────┤
│ 4/030313311232030030032122121030 │
│ 4/030313311232031331311131310220 │
│ 4/030313311232031322310022111120 │
└──────────────────────────────────┘
```

## Hands on: Joining {background-image="bg/wb3.png"}

```{python}
#| echo: true
#| eval: false
con.sql("""
    SELECT zipcodes.zipcode, count(*) as numpoints
    FROM buildings
    LEFT JOIN zipcodes ON
        zipcodes.cell_min <= buildings.cell
        AND zipcodes.cell_max >= buildings.cell
    WHERE s2_contains(zipcodes.geog, buildings.cell)
    GROUP BY zipcode
""")
```

## The Future

- Better integration with `spatial` (e.g., `geog::GEOMETRY`)
- Aggregators
- Import/Export/Fix spherical geometry
- Something else based on user experience?

## duckdb-geography {background-image="bg/wb3.png"}

- [dewey.dunnington.ca/slides/geopython2025](https://dewey.dunnington.ca/slides/geopython2025)
- {{< fa brands github >}} [paleolimbot/duckdb-geography](https://github.com/paleolimbot/duckdb-geography)
- {{< fa globe >}} [duckdb.org/community_extensions](https://duckdb.org/community_extensions/extensions/geography.html)

Install from Python:

```python
import duckdb
duckdb.install_extension("geography", repository="community")
```

Install from SQL:

```sql
INSTALL geography FROM community;
```
